// Generated by CoffeeScript 1.7.1

/*
Implements reading and writing of data to local files using HTML5.
Currently only text files are supported.
Provides limited support of mime types.
Note: Reading is asynchronous, i.e. clients need to provide a callback that consumes data once it's read(y)
Useable only if browser supports HTML5 File APIs, provides for testing such support.
Assumes that jQuery is/will be loaded
(Could be a jQuery plugin)
(Could be a promise/deferred)
(Could be extended to support writing and reading files by dragging them from and to an area on a page)
Copyright 2014 Jan Stelovsky, MIT license (use as you wish, don't complain:)
 */

(function() {
  var File;

  File = (function() {
    function File() {}

    File.mimeTypes = {
      txt: 'text/plain',
      html: 'text/html',
      css: 'text/css',
      json: 'application/json',
      js: 'application/javascript',
      xml: 'application/xml',
      dtd: 'application/xml-dtd',
      png: 'image/png',
      jpeg: 'image/jpeg',
      jpg: 'image/jpeg',
      coffee: 'text/coffee'
    };

    File.defaultType = 'text/plain';

    File.dom = {};

    $(function() {
      var api, onError, onMimeTypes, _i, _len, _ref;
      File.dom.body = $('body');
      File.supported = [];
      File.unsupported = [];
      _ref = ['File', 'FileReader', 'FileList', 'Blob', 'URL'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        api = _ref[_i];
        if (window[api] != null) {
          File.supported.push(api);
        } else {
          File.unsupported.push(api);
        }
      }
      onMimeTypes = function(mimeTypes) {
        var extension, mimeType, type, _j, _len1, _results;
        File.mimeTypes = {};
        _results = [];
        for (_j = 0, _len1 = mimeTypes.length; _j < _len1; _j++) {
          mimeType = mimeTypes[_j];
          _results.push((function() {
            var _results1;
            _results1 = [];
            for (extension in mimeType) {
              type = mimeType[extension];
              _results1.push(File.mimeTypes[extension.replace(/./, '')] = type);
            }
            return _results1;
          })());
        }
        return _results;
      };
      onError = function() {
        return console.log("GET Error:" + (JSON.stringify(arguments)));
      };
      $.when($.getJSON('assets/mime_types.json')).done(onMimeTypes).fail(onError);
      return File;
    });

    File.support = function() {
      var list;
      list = function(names) {
        return (JSON.stringify(names)).replace(/\[(.*)\]/, '$1').replace(/"/g, "'").replace(/,/g, ", ").replace(/(.*),/, '$1 and');
      };
      if (File.unsupported.length === 0) {
        return "Your browser supports all the File-related APIs, i.e.:\n  " + (list(File.supported));
      } else if (File.supported.length === 0) {
        return "Your browser doesn't support any File-related APIs, i.e.:\n  " + (list(File.unsupported));
      } else {
        return "Your browser supports the following APIs:\n  " + (list(File.supported)) + "\nbut doesn't support:\n  " + (list(File.unsupported));
      }
    };

    File.canRead = function() {
      return typeof FileReader !== "undefined" && FileReader !== null;
    };

    File.canWrite = function() {
      return (typeof URL !== "undefined" && URL !== null) && (typeof Blob !== "undefined" && Blob !== null);
    };

    File.type = function(fileName) {
      var extension;
      extension = fileName.match(/\.([0-9a-z]+)(?:[\?#]|$)/i);
      if (!((extension != null) || extension === '' || extension.length < 1)) {
        return File.defaultType;
      }
      extension = extension[1];
      if (File.mimeTypes[extension] != null) {
        return File.mimeTypes[extension];
      } else {
        return File.defaultType;
      }
    };

    File.read = function(onRead, onError, onFile) {
      if (typeof FileReader !== "undefined" && FileReader !== null) {
        if (!File.dom.input) {
          File.dom.input = $('<input>').attr({
            type: 'file',
            href: '#'
          }).hide().appendTo(File.dom.body);
        }
        File.dom.input.on('change', function() {
          var file, reader;
          file = $(this).get(0).files[0];
          if (file != null) {
            if (onFile != null) {
              onFile(file);
            }
            reader = new FileReader();
            reader.onloadend = (function(_this) {
              return function(event) {
                return onRead(event.target.result);
              };
            })(this);
            return reader.readAsText(file);
          } else {
            if (onError != null) {
              return onError("Couldn't get metadata of from element '" + id);
            }
          }
        });
        return File.dom.input.trigger('click');
      } else {
        if (onError != null) {
          return onError("Your browser doesn't support reading files, sorry...");
        }
      }
    };

    File.write = function(fileName, data, onError, onWritten) {
      var cleanUp, href, options, type;
      if ((typeof URL !== "undefined" && URL !== null) && (typeof Blob !== "undefined" && Blob !== null)) {
        if (!File.dom.a) {
          File.dom.a = $('<a>').hide().appendTo(File.dom.body);
        }
        type = File.type(fileName);
        href = URL.createObjectURL(new Blob([data], {
          type: type
        }));
        options = {
          download: fileName,
          href: href,
          'data-downloadurl': "" + type + ":" + fileName + ":" + href
        };
        File.dom.a.attr(options);
        File.dom.a[0].click();
        cleanUp = function() {
          return URL.revokeObjectURL(href);
        };
        return setTimeout(cleanUp, 1500);
      } else {
        if (onError != null) {
          return onError("Your browser doesn't support writing files, sorry...");
        }
      }
    };

    window.URL = window.webkitURL || window.URL;

    if (!window.JS) {
      window.JS = {};
    }

    window.JS.File = File;

    return File;

  })();


  /*
  coffee -cwo /Users/jan/parwinr/parvina.co.nf/parvina.co.nf/javascripts/ /Users/jan/parwinr/parvina.co.nf/parvina.co.nf/coffeescripts/
   */


  /*
      holder = $ '#holder'
      state = $ '#status' 
      if window.FileReader?
        state.className = 'success'
        state.innerHTML = 'File API & FileReader available'
      else
        state.className = 'fail'
   
      holder.ondragover = ->
        @className = 'hover'
        false
      holder.ondragend = ->
        @className = ''
        false
      holder.ondrop = (event) ->
        @className = ''
        event.preventDefault()
        file = event.dataTransfer.files[0]
        reader = new FileReader()
        reader.onload = (event) ->
          console.log event.target
          holder.style.background = "url(#{event.target.result}) no-repeat center"
        console.log file
        reader.readAsDataURL file
        false;
   */

}).call(this);
